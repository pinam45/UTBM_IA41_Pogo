\documentclass[article, backcover, french, nodocumentinfo]{upmethodology-document}
\include{packages}
\include{settings}

\begin{document}
	\upmdocumentsummary{}
	\upmdocumentauthors{}
	%\upmdocumentvalidators{}
	\upmdocumentinformedpeople{}
	\upmpublicationpage{}
	\thispagestyle{empty}
	\tableofcontents{}
	\lstlistoflistings{}
	\listoffigures{}
	\newpage{}

	\section{Sujet, règles du jeu}
		\subsection{Présentation}
			Le but de ce projet est de réaliser une IA capable de jouer au jeu de Pogo. Pour cela l'algorithme \textbf{MinMax} et son optimisation \textbf{AlphaBeta} seront utilisés. Il doit aussi être possible de tester l'IA. Le langage utilisé pour réaliser le projet est le C++ norme 2011.
		\subsection{Règles}
			\p{Matériel}
				\begin{itemize}
					\item Plateau de 9 cases, dimensions 3 $\times$ 3
					\item 6 pions de couleurs différentes pour chaque joueur
				\end{itemize}
			\p{But du jeu}
				Être le premier à avoir une pièce de sa couleur au sommet de chaque pile.
			\p{Position initiale}
				La position initiale est illustrée avec notre interface utilisateur sur la figure \ref{fig:état_initial}.
				\begin{figure}[H]
					\centering
					\includegraphics[width=0.7\textwidth]{figures/ConsoleUI}
					\caption{Plateau: État initial du plateau de jeu}
					\label{fig:état_initial}
				\end{figure}
			\p{Description du jeu}
				A tour de rôle, chaque joueur effectue un déplacement qui doit obéir aux règles suivantes:
				\begin{itemize}
					\item Un joueur peut déplacer au choix, une, deux ou trois pièces, qui doivent déjà être empilées sur la même case.
					\item La pièce au sommet de l’ensemble déplacé doit être de sa couleur. Les pièces de dessous peuvent appartenir à l’autre joueur.
					\item L’ensemble déplacé doit bouger du même nombre de cases que le nombre d’éléments dont il est constitué.
				\end{itemize}
				Les pièces peuvent être déplacées dans toutes les directions, mais pas en diagonale. Le déplacement d’une pile de deux pièces peut se faire en coude. Celui d’une pile de trois pièces peut décrire un ou deux coudes. Peu importe si la case d’arrivée est occupée ou pas. Les cases occupées n’empêchent pas le passage des pièces. La hauteur des piles n’est pas limitée.
		\subsection{Objectifs}
			\p{Objectif premiers}
				Il faut réaliser une IA mais il faut aussi pouvoir tester cette dernière pour évaluer sa performance. Pour pouvoir tester l'IA il faut que le programme propose de jouer en Humains contre IA mais aussi en IA contre IA. Pour cela nous avons fixé les objectifs suivants:
				\begin{itemize}
					\item Implémenter la logique d'un jeu de Pogo
					\item Réaliser une IA capable de jouer au jeu
					\item Réaliser une interface homme-machine pour permettre a l'utilisateur de visualiser le jeu et d'y jouer
				\end{itemize}
			\p{Objectif supplémentaires}
				Nous avons rajouté quelques objectifs supplémentaires afin d'améliorer le programme, faciliter les tests de l'IA et élargir les possibilités de modification de l'IA.
				\begin{itemize}
					\item Permettre de jouer en Humain contre Humain
					\item Permettre de choisir la profondeur d'exploration de l'arbre de l'IA
					\item Proposer plusieurs fonctions d'évaluation d'une situation de jeu et un comparatif de ces dernières
					\item \color{green} Ajouter une non-IA (mouvements aléatoires)
				\end{itemize}
		\subsection{Notes}
			\p{Détails}
				Les fonctions importantes et liées à l'IA seront expliqué et leur fonctionnement détaillé (souvent par un algorithme). Pour les autres fonctions se référer à la documentation Doxygen du code.
				\begin{upminfo}
					Doxygen est un générateur de documentation sous licence libre, une documentation web peut être généré, pour cela voir \href{http://www.stack.nl/~dimitri/doxygen/}{le site web de Doxygen}.
				\end{upminfo}
			\p{Diagrammes}
				Les diagrammes utilisé pour expliciter les classes sont des diagrammes de classe UML dont les spécifications peuvent être obtenues sur le site \href{http://www.omg.org/spec/UML/}{Object Management Group}
	\section{Réalisation}
		\subsection{Représentation du jeu}
			\subsubsection{pions}
				\p{Définition}
					Les pions sont représenté par la classe \jclass{Pawn} définit dans \textbf{Pawn.hpp}
				\p{Observation}
					Les pions on des caractéristiques intrinsèque identiques pour tous comme leur taille, le nombre de poins qu'il valent\ldots Mais ces derniers n'ont qu'une seule caractéristique intrinsèque variable, le joueur auquel ils appartiennent, cette caractéristique n'a que deux valeurs possibles.
				\p{Choix}
					Les pions sont donc représenté par une valeur booléenne:
					\begin{description}
						\item[0] Pion du joueur 1
						\item[1] Pion du joueur 2
					\end{description}
			\subsubsection{Piles de pions}
				\p{Définition}
					Les piles de pions sont représenté par la classe \jclass{PawnStack} définit dans \textbf{PawnStack.hpp}
					\begin{figure}[H]
						\centering
						\includegraphics[width=0.7\textwidth]{figures/PawnStackDiagram}
						\caption{PawnStack: diagramme de classe}
						\label{fig:PawnStackDiagram}
					\end{figure}
				\p{Choix}
					Partant de l'idée qu'un \textbf{bit} (0 ou 1) suffit pour représenter un pions nous avons choisit d'optimiser la mémoire en représentant une pile de pions par un nombre entier (\textit{container}) ou chaque bit qui le compose représente un pion. Le problème qui se pose alors est lorsqu'il n'y a pas de pions puisque chaque valeur possible représente un joueur.
				\p{Taille de la pile}
					Dans notre représentation une pile a un début fixe, le premier élément, mais une fin variable puisque la taille d'une pile est variable. Comme illustré sur la figure \ref{fig:pile_mémoire}, pour définir la taille d'une pile nous avons donc décidé que en partant de la fin (pile complète, 16 pions) que le premier pion au joueur 2 (bit a 1) marquerait la fin de la pile au pions précédent.
					\begin{figure}[H]
						\begin{center}
							\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
								\hline
								Numéro du bit & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15\\
								\hline
								Valeur du bit & 0\cellcolor{green} & 1\cellcolor{green} & 0\cellcolor{green} & 1\cellcolor{green} & 1\cellcolor{green} & 0\cellcolor{green} & 0\cellcolor{green} & 1\cellcolor{green} & 0\cellcolor{green} & 1\cellcolor{orange} & 0\cellcolor{red} & 0\cellcolor{red} & 0\cellcolor{red} & 0\cellcolor{red} & 0\cellcolor{red} & 0\cellcolor{red}\\
								\hline
							\end{tabular}
						\end{center}
						\caption{Pile en mémoire}
						\label{fig:pile_mémoire}
					\end{figure}
					La figure \ref{fig:pile_représentation} illustre la conversion de la représentation mémorielle vers sa signification puis vers l'affichage pour le joueur. La pile dans cet exemple est donc contrôlée par le joueur 1.
					\begin{figure}[H]
						\centering
						\includegraphics[width=\textwidth]{figures/pile}
						\caption{Représentation d'une pile}
						\label{fig:pile_représentation}
					\end{figure}
				\p{Fonction principales}
					La fonction \jfunc{pick} permet de prendre des pions de la pile et la fonction \jfunc{add} permet d'ajouter des pions a la pile, elles son utilisées pour appliquer les mouvements de pions.
			\subsubsection{Mouvements de pions}
				\p{Définition}
					Les mouvements de pions sont représenté par la structure \jclass{PawnsMove} définit dans \textbf{PawnsMove.hpp}
					\begin{figure}[H]
						\centering
						\includegraphics[width=0.25\textwidth]{figures/PawnsMoveDiagram}
						\caption{PawnsMove: diagramme de classe}
						\label{fig:PawnsMoveDiagram}
					\end{figure}
				\p{Choix}
					Cette structure représente un mouvement de pions, elle est généré par les joueurs (humains ou IA) lorsqu'il jouent et est appliqué au plateau.
			\subsubsection{Plateau}
				\p{Définition}
					Le plateau est représenté par la classe \jclass{Board} définit dans \textbf{Board.hpp}
					\begin{figure}[H]
						\centering
						\includegraphics[width=0.8\textwidth]{figures/BoardDiagram}
						\caption{Board: diagramme de classe}
						\label{fig:BoardDiagram}
					\end{figure}
				\p{Choix}
					Le plateau est l'équivalent d'un tableau 2 dimensions $width \times height$, dans notre cas $width$ et $height$ auront pour valeur 3.
				\p{Fonction principales}
					La fonction \jfunc{apply} qui permet d'appliquer un mouvement de pions et ainsi de jouer. La fonction \jfunc{controlledStacks} permet de connaitre le nombre de piles contrôlées par un joueur et donc de savoir si un joueur a gagné, si la fonction retourne 0 pour un joueur, alors ce dernier ne contrôle plus de pile et a donc perdu.
		\subsection{Structure de l'IA}
			\subsubsection{MinMax}
				\lstinputalgo[caption=MinMax]{algorithms/MinMax.algo}
			\subsubsection{AlphaBeta}
				\lstinputalgo[caption=AlphaBeta]{algorithms/AlphaBeta.algo}
			\subsubsection{Génération des coups}
				\paragraph{}
					Pour générer les coups, nous devions modéliser les règles de déplacement. Nous avons d'abord envisagé, pour déterminer tous les déplacements possibles à partir d'une pile, d'utiliser un algorithme récursif, qui déterminerait les piles d'arrivés par diffusion à partir de la pile de départ.\\
					Nous avons finalement opté pour un calcul de distance de Manhattan défini comme:
					\[d((x1,y1),(x2,y2)) = |x2 - x1| + |y2 -y1|\]
				\paragraph{}
					En effet, on observe que l'on peut bouger $p$ pions d'une pile $i$ vers une pile $j$ si l'égalité $d(pile_{i}, pile_{j}) = p$ est vérifiée. Il faut cependant rajouter la possibilité du déplacement de 3 pions d'une distance de 1 case, dû aux déplacements en coudes.\\
					Voici un exemple illustrant tous les déplacements possibles à partir d'une pile, en utilisant les distances de Manhattan (La pile de départ est encadrée en vert).
					\begin{figure}[H]
						\centering
						\includegraphics[width=0.6\textwidth]{figures/GenerationCoup}
						\caption{Génération des coups}
					\end{figure}
			\subsubsection{Fonction d'évaluation}
				\paragraph{}
					Afin d'évaluer la partie nous comptons pour un joueur  le nombre de piles qu’il contrôle, que nous divisons par le nombre total de piles présentes sur le jeu. Notre évaluation représente donc le pourcentage de piles que nous contrôlons. Eval = 0 représente donc une défaite pour le joueur qui évalue car il ne possède aucune pile et Eval = 1 une victoire car il les contrôle toutes. On a donc $Eval \in [0,1]$.\\
					De façon formelle :
					\[
					x_{i} = \left\{
					\begin{array}{ll}
						1 \mbox{ si  on contrôle la pile de la case i} \\
						0  \mbox{ sinon}
					\end{array}
					\right.
					\]
					et $n$ le nombre de piles présentes sur le plateau
					\[Eval = \frac{1}{n}  \sum_{i = 1}^{9} x_{i}\]
					Exemple:
					\begin{center}
						\includegraphics[width=0.6\textwidth]{figures/Eval.png}
					\end{center}
				\paragraph{}
					Dans ce cas pour le joueur violet contrôle 4 piles, et le nombre de piles sur le plateau est de 7, ce qui nous donne $Eval = \frac{4}{7} \simeq 0,571$
		\subsection{Interface utilisateur}
			\subsubsection{Fonctionnalités}
				L'interface graphique est entièrement réalisée en console avec un style ``graphique''. Il y a deux interfaces principales, les menu et messages (d'information, d'erreur\ldots) et le plateau du jeu de Pogo.
				\p{Menus}
					Avant de commencer une partie plusieurs menus se suivent:
					\begin{itemize}
						\item Menus principal: choix du mode de jeu
							\begin{itemize}
								\item Humain contre Humain
								\item Humain contre IA
								\item IA contre IA
							\end{itemize}
						\item Si jeu avec IA (une ou deux): Menu de choix de la profondeur d'exploration de l'arbre de/des IA
						\item Menu de choix de l'ordre de jeu
					\end{itemize}
				\p{Plateau de jeu}
					Le plateau de jeu en 3 $\times$ 3 fait une taille de 98 caractères de large et 53 caractères de haut, si la console n'est pas suffisamment grande pour afficher le plateau un message demandant d'agrandir la console apparaitra. Dans le cas d'une utilisation sous Windows si l'écran ne permet pas d'étendre suffisamment la console on peut faire:\\
					\textit{clique droit sur la barre supérieure > Propriétés > Police > Taille}\\
					et réduire la taille de la police pour augmenter la largeur et hauteur en caractères de la console et permettre l'affichage du plateau.\\

					Lors du tour d'un joueur humain, le plateau permet de choisir un mouvement de la façon suivante:
					\begin{itemize}
						\item Choix de la pile de départ
						\item Choix du nombre de pions a prendre
						\item Choix de la pile d'arrivé
					\end{itemize}
					Lors du choix de la pile de départ et d'arrivé, les choix valides serons affichés en vert.
			\subsubsection{Utilisation}
				\p{Menus}
					Les menus simples s'utilisent avec les contrôles suivants:
					\begin{description}
						\item[Page précédente] Premier choix
						\item[Page suivante] Dernier choix
						\item[Flèche du haut] Choix précédent
						\item[Flèche du bas] Choix suivant
						\item[Entré] Valider le choix
						\item[Échap] Quitter (pas toujours possible)
					\end{description}
					Les menus a options s'utilisent avec les contrôles des menus simples avec en plus que les contrôles suivants:
					\begin{description}
						\item[Début] Première valeur de l'option
						\item[Fin] Dernière valeur de l'option
						\item[Flèche de gauche] Valeur précédente de l'option
						\item[Flèche de droite] Valeur suivante de l'option
					\end{description}
				\p{Plateau de jeu}
					Lors de la sélection d'une pile, les contrôles suivants sont utilisables:
					\begin{description}
						\item[Flèche du haut] Bouger la sélection en haut
						\item[Flèche du bas] Bouger la sélection en bas
						\item[Flèche de gauche] Bouger la sélection à gauche
						\item[Flèche de droite] Bouger la sélection à droite
						\item[Entré] Valider le choix
						\item[Échap] Quitter la partie
					\end{description}
					Lors de la sélection du nombre de pions à prendre dans une pile:
					\begin{description}
						\item[Flèche du haut] Diminuer le nombre de pions pris
						\item[Flèche du bas] Augmenter le nombre de pions pris
						\item[Entré] Valider le choix
						\item[Échap] Quitter la partie
					\end{description}
			\subsubsection{Réalisation}
				\begin{figure}[H]
					\centering
					\includegraphics[width=0.7\textwidth]{figures/UIDiagram}
					\caption{UI et ConsoleUI: diagramme de classe}
					\label{fig:UIDiagram}
				\end{figure}
				L'interface utilisateur du projet est constituée de deux classes:
				\p{UI}
					\texttt{UI} est l'interface (classe purement abstraite) à implémenter pour réaliser une interface homme machine utilisable dans le projet. Elle a 3 paramètres de template: le type de stack utilisé, la largeur du plateau et sa hauteur. Elle possède des fonctions pour afficher le plateau et la victoire mais aussi pour permettre au joueur humain de choisir un mouvement.
				\p{ConsoleUI}
					\texttt{ConsoleUI} est l'implémentation qu'utilise le projet, elle est entièrement en console mais emprunte beaucoup aux interfaces graphiques, elle a été réalisée avec la librairie C, compatible C++ \textbf{ConsoleControl} développée par Maxime Pinard, membre du groupe du projet. Le projet utilise la version 0.2 de la librairie.
					\begin{figure}[H]
						\centering
						\includegraphics[width=0.7\textwidth]{figures/ConsoleUI}
						\caption{ConsoleUI: affichage en console du plateau de jeu}
						\label{fig:ConsoleUI}
					\end{figure}
				\p{ConsoleControl}
					Fonctionnalités:
					\begin{itemize}
						\item Obtention d'informations sur la console (largeur, hauteur\ldots)
						\item Positionnement du curseur
						\item Changement des couleurs d'arrière-plan et de premier plan
						\item Gestion des inputs
						\item Dessin géométrique (lignes, rectangle)
						\item Interface utilisateur:
							\begin{itemize}
								\item Menu
								\item Menu d'options
								\item Messages
							\end{itemize}
						\item \ldots
					\end{itemize}
					Avantages:
					\begin{itemize}
						\item Multiplateforme
						\item Pas de dépendances
						\item Utilisé en sous module compilé en même temps que le projet
					\end{itemize}
					Pour plus d'informations, voir \href{https://github.com/pinam45/ConsoleControl}{la page Github de la librairie}.
				\p{Résultat}
					L'interface du jeu est multiplateforme, dessinée en console, principalement en couleur mais aussi avec des caractères. Nous avons choisi des couleur différente du jeu original de Pogo pour plus de lisibilité dans la console mais les couleurs et les caractères utilisés sont tous des champs privés de \textit{ConsoleUI} et sont donc configurables dans le fichier \texttt{ConsoleUI.hpp}.
	\section{Compilation}
		\subsection{Informations}
		\subsection{Make}
		\subsection{CMake}
	\section{Résultats}
		\subsection{Performances AlphaBeta vs MinMax}
			\paragraph{}
				Nous avons d'abord implémenté une IA reposant sur le MinMax. Nous avons testé jusqu'à quelle profondeur le temps de réponse de l'IA restait raisonnable pour des parties rapides, soit une réponse en quelques secondes (temps < 10 secondes).\\
				La profondeur maximale répondant à ce critère de temps de réponse avec le MinMax est de 5. En élaguant avec l'AlphaBeta, nous sommes parvenus à obtenir une profondeur maximale de 7. Nous pouvons expliquer cette amélioration par la symétrie des coups possibles, et du petit nombre de valeurs différentes que peut prendre notre évaluation.
		\subsection{IA contre IA}
		\subsection{IA contre Humain}
%\begin{upmcaution}
%	This is an example of a caution message. This text must be rendered with enough height (usually 2 lines of text) to avoid intersection between the caution icon and the box frame.
%\end{upmcaution}
%\begin{upminfo}
%	This is an example of an information message. This text must be rendered with enough height (usually 2 lines of text) to avoid intersection between the caution icon and the box frame.
%\end{upminfo}
%\begin{upmquestion}
%	This is an example of a question message. This text must be rendered with enough height (usually 2 lines of text) to avoid intersection between the caution icon and the box frame.
%\end{upmquestion}
%\begin{figure}[H]
%	\centering
%	\includegraphics[width=0.5\textwidth]{figures/sample} % or <figures/sample.jpg>
%	\caption{sample figure}
%	\label{fig:sampleFigure}
%\end{figure}
\end{document}
